Yeah, that error means we’re **still in “RQ hiding the real problem” land**, not “macOS fork crash” anymore.

The `OBJC_DISABLE_INITIALIZE_FORK_SAFETY` env var only helps if the worker process is *crashing* on fork. You’re not crashing now — you’re just getting the same useless:

```text
ValueError: Invalid attribute name: app.tasks.ai_ingestion_worker.analyze_script_partial
```

So the next step is: **force Python (not RQ) to import that attribute in the *same environment* as the worker and show us the real stack trace.**

---

## 1. Reproduce the import the way RQ does

From your **repo root** (the one that has `app/` in it), with the **same venv activated** that the worker uses:

```bash
cd /Users/jacklofwall/Documents/GitHub/writersroom
source writersRoom/bin/activate
```

Create a file `debug_import.py` at repo root:

```python
# debug_import.py
import os
import sys
import traceback

target = "app.tasks.ai_ingestion_worker.analyze_script_partial"

print("Python:", sys.executable)
print("CWD:", os.getcwd())
print("sys.path:")
for p in sys.path:
    print("  ", p)

print(f"\nTrying to import {target!r} ...\n")

try:
    module_name, attr_name = target.rsplit(".", 1)
    module = __import__(module_name, fromlist=[attr_name])
    func = getattr(module, attr_name)
    print("SUCCESS:")
    print("  module:", module)
    print("  func:  ", func)
except Exception:
    print("FAILED to import", target)
    traceback.print_exc()
```

Now run it **using the same env you use for the worker**:

```bash
python debug_import.py
```

One of two things will happen:

### A. It FAILS

You’ll see a stack trace (ModuleNotFoundError, ImportError, RuntimeError, etc.).

That error is **exactly** what RQ is swallowing and turning into `ValueError: Invalid attribute name`.

Common culprits:

* Something inside `app.tasks.ai_ingestion_worker` imports a module that isn’t installed in the worker venv (e.g., `openai`, `tiktoken`, etc.).
* It relies on env vars (API keys, config) that aren’t set when the worker runs, so some settings import explodes.
* Circular imports: `app.tasks.ai_ingestion_worker` imports something that imports it back indirectly.
* The code in that module crashes at import time (e.g., running DB code or reading a file as a side-effect).

**Fix the error you see there**, re-run `debug_import.py` until it prints `SUCCESS`, then your RQ worker will stop throwing the “invalid attribute name” error.

---

### B. It SUCCEEDS

If `debug_import.py` prints `SUCCESS` and shows the function, then:

* The function really is importable in that environment.
* That means your **worker is probably not running in the same environment** (different CWD or `sys.path`).

In that case, I’d stop using the bare `rq worker` CLI and use a **custom worker script** that:

1. Ensures project root is on `sys.path`.
2. Prints debug info so you can confirm.

Example `backend/worker.py` (if your `app` directory is under `backend/`):

```python
# backend/worker.py
import os
import sys
from redis import Redis
from rq import Worker, Queue, Connection

ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

print("Worker Python:", sys.executable)
print("Worker CWD:", os.getcwd())
print("Worker sys.path:")
for p in sys.path:
    print("  ", p)

# Sanity check import in the *worker process*
from app.tasks.ai_ingestion_worker import analyze_script_partial
print("Imported analyze_script_partial OK:", analyze_script_partial)

redis_conn = Redis(host="localhost", port=6379, db=0)

with Connection(redis_conn):
    q = Queue("ai_ingestion")
    w = Worker([q])
    w.work()
```

And in `backend/start_worker.sh`:

```bash
#!/usr/bin/env bash
set -e

cd "$(dirname "$0")"/..  # repo root
source writersRoom/bin/activate

# macOS fork setting (fine for dev)
export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES

cd backend
python worker.py
```

Run:

```bash
chmod +x backend/start_worker.sh
backend/start_worker.sh
```

If `worker.py` itself crashes on the `from app.tasks.ai_ingestion_worker import analyze_script_partial`, you’ll *finally* see the true error.

---

## 2. Double-check the function definition itself

Just to be sure, in `app/tasks/ai_ingestion_worker.py`:

* The function must be **top-level**, not nested inside another function or class:

```python
# app/tasks/ai_ingestion_worker.py
def analyze_script_partial(script_id: str, *args, **kwargs):
    ...
```

* No conditional definition like:

```python
if __name__ == "__main__":
    def analyze_script_partial(...):
        ...
```

RQ is looking for `analyze_script_partial` as a top-level attribute of that module.

---

## 3. The macOS env var vs your current error

Right now:

* The macOS `fork` safety env var doesn’t fix this; the process isn’t crashing, Python is just failing to import your function.
* So don’t worry about that line until after we get `debug_import.py` to succeed.

---

### TL;DR for you right now

1. Run `debug_import.py` as above with your venv active.
2. Whatever stack trace you see is the real blocker — fix that.
3. If `debug_import.py` passes, switch to a custom worker script (`backend/worker.py`) that prints `sys.path` and test the import *inside* that process.

Once we know what actually breaks in `debug_import.py`, the fix will be straightforward.
